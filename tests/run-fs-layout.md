# Run file system layout

These tests illustrate run file layout at a high level. For lower level
tests, see [`run-lifecycle.md`](run-lifecycle.md).

TODO: run various samples to show files after various run commands.

    >>> var_home = make_temp_dir()

    >>> use_project("hello-project", var_home)

    >>> find(".")
    gage.json
    hello.py

    >>> find(var_home)
    <empty>

TODO: implement!

    >>> run("gage run hello.py -y")
    gage: no such operation hello.py
    Try 'gage operations' for a list of operations.
    <1>

TODO: implement!

    >>> find(var_home)
    <empty>

Notes on run dir layout:

```
# Some run dir meta dir

id
ATTRS/label
ATTRS/params
ATTRS/platform
ATTRS/random_seed
ATTRS/tags

OUTPUT
OUTPUT.index

MANIFEST

EXIT
LOCK
STAGED
PENDING

OPREF
OPDEF

CMD
ENV

ID

STARTED
STOPPED
```

Q: Why not capture other topics like metrics and logged attrs? These are
things that we can know by the end of the run, like stopped. Why not
codify these in the meta dir?

A: I think we do! Monitoring TF event files during the run to update
metrics and attributes ought to be something that we do.

Q: What is the difference between Gage core attributes and user logged
attributes?

A: ???

Q: How should we categories stuff that lands in the meta dir? Topics to
consider: when the thing is written, is the thing re-written, is the
thing something a user can specify, what role does the thing play in
using or showing the run?

A: ???

Q: Why are we capitalizing file names?

A: Not sure - no good reason.

```
# op info
opref
opdef

# status markers (optional, one of)
pending
staged

# process attributes
proc/started
proc/stopped
proc/cmd
proc/env
proc/exit
proc/lock
proc/output
proc/output.index

# user attributes
attrs/label
attrs/tags
attrs/comment
attrs/params
attrs/user
attrs/host

# manifest
xxx/manifest
xxx/sourcecode_digest

# system attributes
sys/platform
sys/pip_freeze

# ???
initialized
```

Totally flat

```
cmd
comment
env
exit
host
id
initialized
label
lock
manifest
opdef
opref
output
output.index
params
pending
pip_freeze
platform
sourcecode_digest
staged
started
stopped
tags
user
```

Looking at this the issue is simpler - whatever a user might be able to
override during a run should be placed under `user`.

```

### High level run meta info

__schema__          # schema used for the meta dir (e.g. 1, 2, etc.) -
                    # used to infer the layout and file encoding scheme

id                  # duplicated dirname on original system - used
                    # to restore to dirname location on transfer

opref               # makes this a run meta dir, otherwise dir ignored

### Project info

opdef.json          # saved project info for op (JSON encoded)

### Run file info

manifest            # run files tracked, including generated - finalized
                    # on process exit

sourcecode_digest   # fast way to tie run to a group of source code files

### Timestamps **

initialized         # when meta dir init is completed
staged              # when staging is completed
started             # when run started
stopped             # when run stopped
finalized           # when run is finalized

### Process attributes

proc/cmd **         # flat file command args, one per line
proc/env **         # flat file env, one per line `NAME: VAL`
proc/lock           # current process ID if running
proc/exit           # process exit code if terminated

### User attributes **

user/params         # user specified params
user/label          # user specified label
user/comment        # user specified comment
user/tags           # user specified tags

### Logged results

log/attrs.json      # Summarized attributes
log/metrics.json    # Summarized metrics
log/output          # process output
log/output_index    # process output index
log/runner          # logs generated by the runner (Gage)

### System attributes **

sys/user            # `USER` env var at time of init
sys/hostname        # `HOSTNAME` env var at time of init
sys/pip_freeze      # Python plugin generated file
sys/platform        # `platform()` output at time of init
```

`**` - immutable once written

Notes on status:

- If `initialized` is missing, status is `unknown`
- If neither `staged` nor `started` exist, status is `pending`
- If `staged` exists, status is `staged`
- If `started` exists, check `proc/lock` - if `lock` exists and refers
  to an existing process ID, status is `running` (note, should sanity
  check that process is expected based on `proc/cmd`)
- If `proc/lock` exists and doesn't point to a valid process ID,
  consider run to have failed - `error` status
- If `proc/exit` exists, use that to determine status
- Negative value, status is `terminated`
- Positive value, status is `error`
- 0 value, status is `completed`
- ??? what about `finalized` - if an error occurs during finalization
  and this marker isn't written, how do we treat status? Is there an
  asterisk?

On init:

- [x] Create meta dir
- [x] Write schema **
- [x] Create `log` subdir
- [x] Start logging to `log/runner` (actions affecting run get logged!)
- [x] Write id **
- [ ] Write opref **
- [ ] Write opdef.json **
- [ ] Write cmd **
- [ ] Write env **
- [ ] Write user attributes **
- [ ] Write system attributes **
- [x] Write initialized marker **

`**` make files read-only

What to do when process exits?

- Delete lock file
- Write exit code
- Write stopped timestamp
- Flush any runner logs (going to `log/runner`)
- Finalize manifest by writing generated files with sha's
- Write `finalized` timestamp
