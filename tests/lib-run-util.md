# Run utils

    >>> from gage._internal.types import *
    >>> from gage._internal.run_util import *

## Make run

`make_run()` creates a new run in a runs root directory.

    >>> runs_root = make_temp_dir()
    >>> run = make_run(runs_root)

    >>> ls(runs_root, include_dirs=True)  # +parse
    {x:run_id}

    >>> assert x == run.id

## Init run meta

`init_run_meta()` initializes the run meta directory. It requires a run,
an op ref, an op def, op config, and an op command.

    >>> init_run_meta(run, OpRef("test", "test"), OpDef("test", {}), {}, OpCmd([], {}))

`run_meta_dir()` and `run_meta_path()` provide run meta paths.

    >>> ls(run_meta_dir(run))
    __schema__
    config.json
    id
    initialized
    log/runner
    name
    opdef.json
    opref
    proc/cmd
    proc/env

    >>> cat(run_meta_path(run, "opdef.json"))
    {}

### Errors

`init_run_meta()` confirms that the opref op name and the op def op name
are the same.

    >>> tmp = make_temp_dir()
    >>> run = make_run(tmp)

    >>> init_run_meta(run, OpRef("test", "hi"), OpDef("bye", {}), {}, OpCmd([], {}))
    Traceback (most recent call last):
    ValueError: mismatched names in opref ('hi') and opdef ('bye')

    >>> ls(tmp)
    <empty>

## Copy source code

Source code copy is performed at two levels:

- Copy files matching `sourcecode` path patterns
- Run `copy-sourcecode` exec if specified

Create a sample project. The project has a `setup.py` script that is
used to initialize `config.json`.

    >>> project_dir = make_temp_dir()
    >>> cd(project_dir)

Sample train script (empty):

    >>> touch("train.py")

`setup.py` that generates config from a template. This script is run for
the copy source code phase.

    >>> write("config.json.in", "{\"x\": 123}")
    >>> write("setup.py", """
    ... import os, json
    ... run_dir = os.environ["run_dir"]
    ... print("Creating config.json from config.json.in")
    ... config = json.load(open("config.json.in"))
    ... config["x"] = config["x"] + 1
    ... print(f"Using x = {config['x']} for config")
    ... with open(os.path.join(run_dir, "config.json"), "w") as f:
    ...     json.dump(config, f)
    ... """)

Initialize a run with an opdef def that copies specifies the source code
to copy and also runs `setup.py` to generate `config.json` in the run
directory.

    >>> opdef = OpDef("test", {
    ...     "sourcecode": ["train.py"],
    ...     "exec": {
    ...         "copy-sourcecode": ["python", "setup.py"]
    ...     }
    ... })

    >>> runs_home = make_temp_dir()

    >>> run = make_run(runs_home)

    >>> init_run_meta(run, OpRef("test", "test"), opdef, {}, OpCmd([], {}))

Use `copy_sourcecode()` to copy the source code and run the source code
exec.

    >>> copy_sourcecode(run, project_dir)

List the run files.

    >>> ls(run.run_dir)
    config.json
    train.py

`setup.py` generates config derived from `config.json.in`.

    >>> cat(path_join(run.run_dir, "config.json"))
    {"x": 124}

The output file `10_sourcecode` is written to meta.

    >>> ls(run_meta_dir(run))  # +diff
    __schema__
    config.json
    id
    initialized
    log/files
    log/runner
    name
    opdef.json
    opref
    output/10_sourcecode
    output/10_sourcecode.index
    proc/cmd
    proc/env

This contains the output generated by `setup.py`.

    >>> cat(run_meta_path(run, "output", "10_sourcecode"))
    Creating config.json from config.json.in
    Using x = 124 for config

`copy-sourcecode` phase events are written to the runner log.

    >>> cat_log(run_meta_path(run, "log", "runner"))  # +diff -space
    Writing meta id
    Writing meta name
    Writing meta opdef.json
    Writing meta config.json
    Writing meta proc/cmd
    Writing meta proc/env
    Writing meta opref
    Writing meta initialized
    Copying source code (see log/files for details): ['train.py']
    Running copy-sourcecode (see output/10_sourcecode for output):
    ['python', 'setup.py']
    Exit code for copy-sourcecode: 0

The list of source code files in `log/files` reflects the creation of
`config.json` by the copy sourcecode exec command.

    >>> cat(run_meta_path(run, "log", "files"))  # +parse
    a s {:timestamp} config.json
    a s {:timestamp} train.py

`config.json` appears in the run manifest when meta staging is finalized.

    >>> finalize_staged_run(run)

    >>> cat(run_meta_path(run, "manifest"))
    s 5cc1441b4902cd35921288754e412e0eb949d44d81e4e0fcb281a913a7c3e820 config.json
    s e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 train.py

## Copy deps

Like source code, dependencies are resolved at two levels:

- Copy files matching `requires` path patterns
- Run `copy-deps` exec if specified

`requires` support is pending. We show how `copy-deps` is used to copy
dependencies from a project directory to a run directory.

Create a project structure.

    >>> project_dir = make_temp_dir()
    >>> cd(project_dir)

Create a sample train script (empty).

    >>> touch("train.py")

Create a script that generates a required file `data.json`.

    >>> write("setup.py", """
    ... import sys, json, os
    ... x = int(sys.argv[1])
    ... dest = os.path.join(os.environ["run_dir"], "data.json")
    ... print(f"Creating data.json with x = {x}")
    ... json.dump({"x": x}, open(dest, "w"))
    ... """)

Create a new run.

    >>> run = make_run(runs_root)

The op def specifies `train.py` as source code and uses `copy-deps` to
run `setup.py` to generate `data.json`.

    >>> opdef = OpDef("test", {
    ...     "sourcecode": "train.py",
    ...     "exec": {
    ...         "copy-deps": ["python", "setup.py", "456"]
    ...     }
    ... })

    >>> init_run_meta(run, OpRef("test", "test"), opdef, {}, OpCmd([], {}))

Use `copy_deps()` to run the copy deps exec command.

    >>> copy_deps(run, project_dir)

The runner log shows copy deps info.

    >>> cat_log(run_meta_path(run, "log", "runner"))  # +wildcard
    Writing meta id
    ...
    Running copy-deps (see output/30_deps for output): ['python', 'setup.py', '456']
    Exit code for copy-deps: 0

Output for the copy command is in `output/30_deps`.

    >>> ls(run_meta_dir(run))  # +wildcard
    __schema__
    ...
    output/30_deps
    output/30_deps.index
    ...

    >>> cat(run_meta_path(run, "output", "30_deps"))
    Creating data.json with x = 456

Files logged:

    >>> cat(run_meta_path(run, "log", "files"))  # +parse
    a d {:timestamp} data.json

The 'd' in the record means the file is logged as a dependency.

List the run files.

    >>> ls(run.run_dir)
    data.json

Note that source code is not copied - we only called `copy_deps()` up to
this point. To copy source code, use `copy_sourcecode()`.

    >>> copy_sourcecode(run, project_dir)

    >>> ls(run.run_dir)
    data.json
    train.py
